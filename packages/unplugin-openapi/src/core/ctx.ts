import { dirname, isAbsolute, join, relative, resolve } from 'node:path'
import { existsSync, promises as fs } from 'node:fs'
import process from 'node:process'
import { createUnimport, scanExports } from 'unimport'
import { vueTemplateAddon } from 'unimport/addons'
import { isPackageExists } from 'local-pkg'
import { pick, throttle } from 'lodash-es'
import MagicString from 'magic-string'
import type { Import } from 'unimport'
import fg from 'fast-glob'
import type { ImportExtended, Options } from '../types'
import { generateOpenAPI } from './generate'
import { slash } from './utils'

export function createContext(rawOptions: Options, root = process.cwd()) {
  root = slash(root)

  const options = {
    imports: 'import request from \'../index\'',
    output: './src/api/service',
    watch: true,
    batch: [],
    ...rawOptions,
  }

  const preferDTS = options?.dts ?? isPackageExists('typescript')
  const batch = options.batch.length > 0 ? options.batch : [pick(options, ['imports', 'input', 'output'])]
  const noInput = !batch[0].input
  const outputs = batch.map(e => e.output)
  const dirs = outputs
    .concat(outputs.map(dir => join(dir as string, '*.{tsx,jsx,ts,js,mjs,cjs,mts,cts}')))
    .map(dir => slash(resolveGlobsExclude(root, dir as string)))

  const unimport = createUnimport({
    imports: [],
    addons: [
      ...(options.vueTemplate ? [vueTemplateAddon()] : []),
      {
        declaration(dts) {
          return `${`
/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by @pubinfo/unplugin-openapi
${dts}`.trim()}\n`
        },
      },
    ],
  })

  function generateTS() {
    if (noInput)
      return

    batch.forEach((opt) => {
      generateOpenAPI({
        ...options,
        ...opt,
      }, root)
    })
  }

  const dts = preferDTS === false
    ? false
    : preferDTS === true
      ? resolve(root, 'openapi.d.ts')
      : resolve(root, preferDTS)

  const multilineCommentsRE = /\/\*.*?\*\//gms
  const singlelineCommentsRE = /\/\/.*$/gm
  const dtsReg = /declare\s+global\s*{(.*?)[\n\r]}/s
  const componentCustomPropertiesReg = /interface\s+ComponentCustomProperties\s*{(.*?)[\n\r]}/gs
  function parseDTS(dts: string) {
    dts = dts
      .replace(multilineCommentsRE, '')
      .replace(singlelineCommentsRE, '')

    const code = dts.match(dtsReg)?.[0]
    if (!code)
      return

    return Object.fromEntries(Array.from(code.matchAll(/['"]?(const\s*[^\s'"]+)['"]?\s*:\s*(.+?)[,;\r\n]/g)).map(i => [i[1], i[2]]))
  }

  async function generateDTS(file: string) {
    const dir = dirname(file)
    const originalContent = existsSync(file) ? await fs.readFile(file, 'utf-8') : ''
    const originalDTS = parseDTS(originalContent)
    let currentContent = await unimport.generateTypeDeclarations({
      resolvePath: (i) => {
        if (i.from.startsWith('.') || isAbsolute(i.from)) {
          const related = slash(relative(dir, i.from).replace(/\.ts(x)?$/, ''))
          return !related.startsWith('.')
            ? `./${related}`
            : related
        }
        return i.from
      },
    })
    const currentDTS = parseDTS(currentContent)!
    if (options.vueTemplate) {
      currentContent = currentContent.replace(
        componentCustomPropertiesReg,
        $1 => `interface GlobalComponents {}\n  ${$1}`,
      )
    }
    if (originalDTS) {
      Object.keys(currentDTS).forEach((key) => {
        originalDTS[key] = currentDTS[key]
      })
      const dtsList = Object.keys(originalDTS).sort().map(k => `  ${k}: ${originalDTS[k]}`)
      return currentContent.replace(dtsReg, () => `declare global {\n${dtsList.join('\n')}\n}`)
    }

    return currentContent
  }

  const writeConfigFilesThrottled = throttle(writeConfigFiles, 500, { leading: true })

  let lastDTS: string | undefined
  async function writeConfigFiles() {
    if (noInput)
      return

    const promises: any[] = []

    if (dts) {
      promises.push(
        generateDTS(dts).then((content) => {
          if (content !== lastDTS) {
            lastDTS = content
            return writeFile(dts, content)
          }
        }),
      )
    }

    return Promise.all(promises)
  }

  async function scanDirs() {
    if (noInput)
      return

    if (dirs?.length) {
      await unimport.modifyDynamicImports(async (imports) => {
        const exports_ = await scanDirExports(dirs, root) as ImportExtended[]
        exports_.forEach(i => i.__source = 'dir')
        return modifyDefaultExportsAlias([
          ...imports.filter((i: ImportExtended) => i.__source !== 'dir'),
          ...exports_,
        ], options)
      })
    }

    writeConfigFilesThrottled()
  }

  async function transform(code: string, id: string) {
    const s = new MagicString(code)

    await unimport.injectImports(s, id)

    if (!s.hasChanged())
      return

    writeConfigFilesThrottled()

    return {
      code: s.toString(),
      map: s.generateMap({ source: id, includeContent: true, hires: true }),
    }
  }

  return {
    root,
    dirs,
    generateTS,
    scanDirs,
    writeConfigFiles,
    writeConfigFilesThrottled,
    transform,
  }
}

function resolveGlobsExclude(root: string, glob: string) {
  const excludeReg = /^!/
  return `${excludeReg.test(glob) ? '!' : ''}${resolve(root, glob.replace(excludeReg, ''))}`
}

function modifyDefaultExportsAlias(imports: ImportExtended[], options: Options): Import[] {
  if (options.defaultExportByFilename) {
    imports.forEach((i) => {
      if (i.name === 'default')
        i.as = i.from.split('/').pop()?.split('.')?.shift() ?? i.as
    })
  }

  return imports as Import[]
}

async function scanDirExports(dirs: string[], root: string) {
  const result = await fg(dirs, {
    absolute: true,
    cwd: root,
    onlyFiles: true,
    followSymbolicLinks: true,
  })

  const files = Array.from(new Set(result.flat())).map(slash)
  return (await Promise.all(files.map(i => scanExports(i, false)))).flat()
}

async function writeFile(filePath: string, content = '') {
  await fs.mkdir(dirname(filePath), { recursive: true })
  return await fs.writeFile(filePath, content, 'utf-8')
}
